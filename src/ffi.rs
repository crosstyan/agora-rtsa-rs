/* automatically generated by rust-bindgen 0.60.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const AGORA_RTC_CHANNEL_NAME_MAX_LEN: u32 = 64;
pub const AGORA_RTC_USER_ID_MAX_LEN: u32 = 255;
pub const AGORA_RTC_PRODUCT_ID_MAX_LEN: u32 = 63;
pub const AGORA_RTM_UID_MAX_LEN: u32 = 64;
pub const AGORA_RTM_DATA_MAX_LEN: u32 = 32768;
pub const AGORA_CREDENTIAL_MAX_LEN: u32 = 256;
pub const AGORA_CERTIFICATE_MAX_LEN: u32 = 1024;
pub const AGORA_LICENSE_VALUE_LEN: u32 = 32;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_int;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    test_field___clang_max_align_nonce2();
}
#[doc = " No error."]
pub const agora_err_code_e_ERR_OKAY: agora_err_code_e = 0;
#[doc = " General error"]
pub const agora_err_code_e_ERR_FAILED: agora_err_code_e = 1;
#[doc = " Network is unavailable"]
pub const agora_err_code_e_ERR_NET_DOWN: agora_err_code_e = 14;
#[doc = " Request to join channel is rejected."]
#[doc = " It occurs when local user is already in channel and try to join the same channel again."]
pub const agora_err_code_e_ERR_JOIN_CHANNEL_REJECTED: agora_err_code_e = 17;
#[doc = " App ID is invalid."]
pub const agora_err_code_e_ERR_INVALID_APP_ID: agora_err_code_e = 101;
#[doc = " Channel is invalid."]
pub const agora_err_code_e_ERR_INVALID_CHANNEL_NAME: agora_err_code_e = 102;
#[doc = " Fails to get server resources in the specified region."]
pub const agora_err_code_e_ERR_NO_SERVER_RESOURCES: agora_err_code_e = 103;
#[doc = " Server rejected request to look up channel."]
pub const agora_err_code_e_ERR_LOOKUP_CHANNEL_REJECTED: agora_err_code_e = 105;
#[doc = " Server rejected request to open channel."]
pub const agora_err_code_e_ERR_OPEN_CHANNEL_REJECTED: agora_err_code_e = 107;
#[doc = " Token expired due to reasons belows:"]
#[doc = " - Authorized Timestamp expired:      The timestamp is represented by the number of"]
#[doc = "                                      seconds elapsed since 1/1/1970. The user can use"]
#[doc = "                                      the Token to access the Agora service within five"]
#[doc = "                                      minutes after the Token is generated. If the user"]
#[doc = "                                      does not access the Agora service after five minutes,"]
#[doc = "                                      this Token will no longer be valid."]
#[doc = " - Call Expiration Timestamp expired: The timestamp indicates the exact time when a"]
#[doc = "                                      user can no longer use the Agora service (for example,"]
#[doc = "                                      when a user is forced to leave an ongoing call)."]
#[doc = "                                      When the value is set for the Call Expiration Timestamp,"]
#[doc = "                                      it does not mean that the Token will be expired,"]
#[doc = "                                      but that the user will be kicked out of the channel."]
pub const agora_err_code_e_ERR_TOKEN_EXPIRED: agora_err_code_e = 109;
#[doc = " Token is invalid due to reasons belows:"]
#[doc = " - If application certificate is enabled on the Dashboard,"]
#[doc = "   valid token SHOULD be set when invoke."]
#[doc = ""]
#[doc = " - If uid field is mandatory, users must specify the same uid as the one used to generate the token,"]
#[doc = "   when calling `agora_rtc_join_channel`."]
pub const agora_err_code_e_ERR_INVALID_TOKEN: agora_err_code_e = 110;
#[doc = " Dynamic token has been enabled, but is not provided when joining the channel."]
#[doc = "  Please specify the valid token when calling `agora_rtc_join_channel`."]
pub const agora_err_code_e_ERR_DYNAMIC_TOKEN_BUT_USE_STATIC_KEY: agora_err_code_e = 115;
#[doc = " Switching roles failed."]
#[doc = "  Please try to rejoin the channel."]
pub const agora_err_code_e_ERR_SET_CLIENT_ROLE_NOT_AUTHORIZED: agora_err_code_e = 119;
#[doc = " Decryption fails. The user may have used a different encryption password to join the channel."]
#[doc = "  Check your settings or try rejoining the channel."]
pub const agora_err_code_e_ERR_DECRYPTION_FAILED: agora_err_code_e = 120;
#[doc = " Decryption fails. The user may have used a different encryption password to join the channel."]
#[doc = "  Check your settings or try rejoining the channel."]
pub const agora_err_code_e_ERR_OPEN_CHANNEL_INVALID_TICKET: agora_err_code_e = 121;
#[doc = " Decryption fails. The user may have used a different encryption password to join the channel."]
#[doc = "  Check your settings or try rejoining the channel."]
pub const agora_err_code_e_ERR_OPEN_CHANNEL_TRY_NEXT_VOS: agora_err_code_e = 122;
#[doc = " Client is banned by the server"]
pub const agora_err_code_e_ERR_CLIENT_IS_BANNED_BY_SERVER: agora_err_code_e = 123;
#[doc = " Sending video data too fast and over the bandwidth limit."]
#[doc = "  Very likely that packet loss occurs with this sending speed."]
pub const agora_err_code_e_ERR_SEND_VIDEO_OVER_BANDWIDTH_LIMIT: agora_err_code_e = 200;
#[doc = " Audio decoder does not match incoming audio data type."]
#[doc = "  Currently SDK built-in audio codec only supports G722 and OPUS."]
pub const agora_err_code_e_ERR_AUDIO_DECODER_NOT_MATCH_AUDIO_FRAME: agora_err_code_e = 201;
#[doc = " Audio decoder does not match incoming audio data type."]
#[doc = "  Currently SDK built-in audio codec only supports G722 and OPUS."]
pub const agora_err_code_e_ERR_NO_AUDIO_DECODER_TO_HANDLE_AUDIO_FRAME: agora_err_code_e = 202;
#[doc = " Error code."]
pub type agora_err_code_e = ::std::os::raw::c_uint;
#[doc = " 0: Remote user leaves channel actively"]
pub const user_offline_reason_e_USER_OFFLINE_QUIT: user_offline_reason_e = 0;
#[doc = " 1: Remote user is dropped due to timeout"]
pub const user_offline_reason_e_USER_OFFLINE_DROPPED: user_offline_reason_e = 1;
#[doc = " The definition of the user_offline_reason_e enum."]
pub type user_offline_reason_e = ::std::os::raw::c_uint;
pub const video_data_type_e_VIDEO_DATA_TYPE_YUV420: video_data_type_e = 0;
pub const video_data_type_e_VIDEO_DATA_TYPE_H264: video_data_type_e = 2;
pub const video_data_type_e_VIDEO_DATA_TYPE_H265: video_data_type_e = 3;
pub const video_data_type_e_VIDEO_DATA_TYPE_GENERIC: video_data_type_e = 6;
pub const video_data_type_e_VIDEO_DATA_TYPE_GENERIC_JPEG: video_data_type_e = 20;
#[doc = " The definition of the video_data_type_e enum."]
pub type video_data_type_e = ::std::os::raw::c_uint;
#[doc = " 0: unknow frame type"]
#[doc = " If you set it ,the SDK will judge the frame type"]
pub const video_frame_type_e_VIDEO_FRAME_AUTO_DETECT: video_frame_type_e = 0;
#[doc = " 3: key frame"]
pub const video_frame_type_e_VIDEO_FRAME_KEY: video_frame_type_e = 3;
#[doc = " 3: key frame"]
pub const video_frame_type_e_VIDEO_FRAME_DELTA: video_frame_type_e = 4;
#[doc = " The definition of the video_frame_type_e enum."]
pub type video_frame_type_e = ::std::os::raw::c_uint;
#[doc = " 1: 1 fps."]
pub const video_frame_rate_e_VIDEO_FRAME_RATE_FPS_1: video_frame_rate_e = 1;
#[doc = " 7: 7 fps."]
pub const video_frame_rate_e_VIDEO_FRAME_RATE_FPS_7: video_frame_rate_e = 7;
#[doc = " 10: 10 fps."]
pub const video_frame_rate_e_VIDEO_FRAME_RATE_FPS_10: video_frame_rate_e = 10;
#[doc = " 15: 15 fps."]
pub const video_frame_rate_e_VIDEO_FRAME_RATE_FPS_15: video_frame_rate_e = 15;
#[doc = " 24: 24 fps."]
pub const video_frame_rate_e_VIDEO_FRAME_RATE_FPS_24: video_frame_rate_e = 24;
#[doc = " 30: 30 fps."]
pub const video_frame_rate_e_VIDEO_FRAME_RATE_FPS_30: video_frame_rate_e = 30;
#[doc = " 60: 60 fps. Applies to Windows and macOS only."]
pub const video_frame_rate_e_VIDEO_FRAME_RATE_FPS_60: video_frame_rate_e = 60;
#[doc = " The definition of the video_frame_rate_e enum."]
pub type video_frame_rate_e = ::std::os::raw::c_uint;
#[doc = " 0: The high-quality video stream, which has a higher resolution and bitrate."]
pub const video_stream_type_e_VIDEO_STREAM_HIGH: video_stream_type_e = 0;
#[doc = " 1: The low-quality video stream, which has a lower resolution and bitrate."]
pub const video_stream_type_e_VIDEO_STREAM_LOW: video_stream_type_e = 1;
#[doc = " Video stream types."]
pub type video_stream_type_e = ::std::os::raw::c_uint;
#[doc = " The definition of the video_frame_info_t struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_frame_info_t {
    #[doc = " The video data type: #video_data_type_e."]
    pub data_type: video_data_type_e,
    #[doc = " The video stream type: #video_stream_type_e"]
    pub stream_type: video_stream_type_e,
    #[doc = " The frame type of the encoded video frame: #video_frame_type_e."]
    pub frame_type: video_frame_type_e,
    #[doc = " The number of video frames per second."]
    #[doc = " -This value will be used for calculating timestamps of the encoded image."]
    #[doc = " - If frame_per_sec equals zero, then real timestamp will be used."]
    #[doc = " - Otherwise, timestamp will be adjusted to the value of frame_per_sec set."]
    pub frame_rate: video_frame_rate_e,
}
#[test]
fn bindgen_test_layout_video_frame_info_t() {
    assert_eq!(
        ::std::mem::size_of::<video_frame_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(video_frame_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<video_frame_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(video_frame_info_t))
    );
    fn test_field_data_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<video_frame_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(video_frame_info_t),
                "::",
                stringify!(data_type)
            )
        );
    }
    test_field_data_type();
    fn test_field_stream_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<video_frame_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream_type) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(video_frame_info_t),
                "::",
                stringify!(stream_type)
            )
        );
    }
    test_field_stream_type();
    fn test_field_frame_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<video_frame_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(video_frame_info_t),
                "::",
                stringify!(frame_type)
            )
        );
    }
    test_field_frame_type();
    fn test_field_frame_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<video_frame_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(video_frame_info_t),
                "::",
                stringify!(frame_rate)
            )
        );
    }
    test_field_frame_rate();
}
#[doc = " 0: Disable"]
pub const audio_codec_type_e_AUDIO_CODEC_DISABLED: audio_codec_type_e = 0;
#[doc = " 1: OPUS"]
pub const audio_codec_type_e_AUDIO_CODEC_TYPE_OPUS: audio_codec_type_e = 1;
#[doc = " 2: G722"]
pub const audio_codec_type_e_AUDIO_CODEC_TYPE_G722: audio_codec_type_e = 2;
#[doc = " 3: G711A"]
pub const audio_codec_type_e_AUDIO_CODEC_TYPE_G711A: audio_codec_type_e = 3;
#[doc = " 4: G711U"]
pub const audio_codec_type_e_AUDIO_CODEC_TYPE_G711U: audio_codec_type_e = 4;
#[doc = " Audio codec type list."]
pub type audio_codec_type_e = ::std::os::raw::c_uint;
#[doc = " 1: OPUS"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_OPUS: audio_data_type_e = 1;
#[doc = " 2: OPUSFB"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_OPUSFB: audio_data_type_e = 2;
#[doc = " 3: PCMA"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_PCMA: audio_data_type_e = 3;
#[doc = " 4: PCMU"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_PCMU: audio_data_type_e = 4;
#[doc = " 5: G722"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_G722: audio_data_type_e = 5;
#[doc = " 8: AACLC"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_AACLC: audio_data_type_e = 8;
#[doc = " 9: HEAAC"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_HEAAC: audio_data_type_e = 9;
#[doc = " 100: PCM (audio codec should be enabled)"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_PCM: audio_data_type_e = 100;
#[doc = " 253: GENERIC"]
pub const audio_data_type_e_AUDIO_DATA_TYPE_GENERIC: audio_data_type_e = 253;
#[doc = " Audio data type list."]
pub type audio_data_type_e = ::std::os::raw::c_uint;
#[doc = " The definition of the audio_frame_info_t struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_frame_info_t {
    #[doc = " Audio data type, reference #audio_data_type_e."]
    pub data_type: audio_data_type_e,
}
#[test]
fn bindgen_test_layout_audio_frame_info_t() {
    assert_eq!(
        ::std::mem::size_of::<audio_frame_info_t>(),
        4usize,
        concat!("Size of: ", stringify!(audio_frame_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_frame_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(audio_frame_info_t))
    );
    fn test_field_data_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audio_frame_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(audio_frame_info_t),
                "::",
                stringify!(data_type)
            )
        );
    }
    test_field_data_type();
}
pub const rtc_log_level_e_RTC_LOG_DEFAULT: rtc_log_level_e = 0;
pub const rtc_log_level_e_RTC_LOG_EMERG: rtc_log_level_e = 1;
pub const rtc_log_level_e_RTC_LOG_ALERT: rtc_log_level_e = 2;
pub const rtc_log_level_e_RTC_LOG_CRIT: rtc_log_level_e = 3;
pub const rtc_log_level_e_RTC_LOG_ERROR: rtc_log_level_e = 4;
pub const rtc_log_level_e_RTC_LOG_WARNING: rtc_log_level_e = 5;
pub const rtc_log_level_e_RTC_LOG_NOTICE: rtc_log_level_e = 6;
pub const rtc_log_level_e_RTC_LOG_INFO: rtc_log_level_e = 7;
pub const rtc_log_level_e_RTC_LOG_DEBUG: rtc_log_level_e = 8;
#[doc = " The definition of log level enum"]
pub type rtc_log_level_e = ::std::os::raw::c_uint;
pub const area_code_e_AREA_CODE_DEFAULT: area_code_e = 0;
pub const area_code_e_AREA_CODE_CN: area_code_e = 1;
pub const area_code_e_AREA_CODE_NA: area_code_e = 2;
pub const area_code_e_AREA_CODE_EU: area_code_e = 4;
pub const area_code_e_AREA_CODE_AS: area_code_e = 8;
pub const area_code_e_AREA_CODE_JP: area_code_e = 16;
pub const area_code_e_AREA_CODE_IN: area_code_e = 32;
pub const area_code_e_AREA_CODE_OC: area_code_e = 64;
pub const area_code_e_AREA_CODE_SA: area_code_e = 128;
pub const area_code_e_AREA_CODE_AF: area_code_e = 256;
pub const area_code_e_AREA_CODE_KR: area_code_e = 512;
pub const area_code_e_AREA_CODE_OVS: area_code_e = 4294967294;
pub const area_code_e_AREA_CODE_GLOB: area_code_e = 4294967295;
#[doc = " IP areas."]
pub type area_code_e = ::std::os::raw::c_uint;
#[doc = " log config"]
#[repr(C)]
#[derive(Debug)]
pub struct log_config_t {
    pub log_disable: bool,
    pub log_disable_desensitize: bool,
    pub log_level: rtc_log_level_e,
    pub log_path: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_log_config_t() {
    assert_eq!(
        ::std::mem::size_of::<log_config_t>(),
        16usize,
        concat!("Size of: ", stringify!(log_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<log_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(log_config_t))
    );
    fn test_field_log_disable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log_config_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_disable) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(log_config_t),
                "::",
                stringify!(log_disable)
            )
        );
    }
    test_field_log_disable();
    fn test_field_log_disable_desensitize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log_config_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_disable_desensitize) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(log_config_t),
                "::",
                stringify!(log_disable_desensitize)
            )
        );
    }
    test_field_log_disable_desensitize();
    fn test_field_log_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log_config_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(log_config_t),
                "::",
                stringify!(log_level)
            )
        );
    }
    test_field_log_level();
    fn test_field_log_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log_config_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_path) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(log_config_t),
                "::",
                stringify!(log_path)
            )
        );
    }
    test_field_log_path();
}
#[doc = " The definition of the service option"]
#[repr(C)]
#[derive(Debug)]
pub struct rtc_service_option_t {
    #[doc = " area code for regional restriction, default is golbal, Supported areas refer to enum area_code_e"]
    #[doc = " and bit operations for multiple regions are supported"]
    pub area_code: u32,
    #[doc = " the  product_id (device name), the max product_id length is 63"]
    pub product_id: [::std::os::raw::c_char; 64usize],
    #[doc = " sdk log config"]
    pub log_cfg: log_config_t,
    #[doc = " license value return when license actived, the max license_value length is 32"]
    #[doc = " Supported character scopes are:"]
    #[doc = " - The 26 lowercase English letters: a to z"]
    #[doc = " - The 26 uppercase English letters: A to Z"]
    #[doc = " - The 10 numbers: 0 to 9"]
    pub license_value: [::std::os::raw::c_char; 33usize],
}
#[test]
fn bindgen_test_layout_rtc_service_option_t() {
    assert_eq!(
        ::std::mem::size_of::<rtc_service_option_t>(),
        128usize,
        concat!("Size of: ", stringify!(rtc_service_option_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rtc_service_option_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rtc_service_option_t))
    );
    fn test_field_area_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_service_option_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).area_code) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_service_option_t),
                "::",
                stringify!(area_code)
            )
        );
    }
    test_field_area_code();
    fn test_field_product_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_service_option_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).product_id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_service_option_t),
                "::",
                stringify!(product_id)
            )
        );
    }
    test_field_product_id();
    fn test_field_log_cfg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_service_option_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_cfg) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_service_option_t),
                "::",
                stringify!(log_cfg)
            )
        );
    }
    test_field_log_cfg();
    fn test_field_license_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_service_option_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).license_value) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_service_option_t),
                "::",
                stringify!(license_value)
            )
        );
    }
    test_field_license_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_codec_option_t {
    #[doc = " Configure sdk built-in audio codec"]
    #[doc = " If AUDIO_CODEC_TYPE_OPUS is selected, your PCM data is encoded as OPUS and then streamed to Agora channel"]
    #[doc = " If AUDIO_CODEC_TYPE_G722 is selected, your PCM data is encoded as G722 and then streamed to Agora channel"]
    #[doc = " If you provide encoded audio data, such as AAC, instead of raw PCM, please disable audio codec by selecting AUDIO_CODEC_DISABLED"]
    pub audio_codec_type: audio_codec_type_e,
    #[doc = " Pcm sample rate. Ignored if audio coded is diabled"]
    pub pcm_sample_rate: ::std::os::raw::c_int,
    #[doc = " Pcm channel number. Ignored if audio coded is diabled"]
    pub pcm_channel_num: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_audio_codec_option_t() {
    assert_eq!(
        ::std::mem::size_of::<audio_codec_option_t>(),
        12usize,
        concat!("Size of: ", stringify!(audio_codec_option_t))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_codec_option_t>(),
        4usize,
        concat!("Alignment of ", stringify!(audio_codec_option_t))
    );
    fn test_field_audio_codec_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audio_codec_option_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).audio_codec_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(audio_codec_option_t),
                "::",
                stringify!(audio_codec_type)
            )
        );
    }
    test_field_audio_codec_type();
    fn test_field_pcm_sample_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audio_codec_option_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pcm_sample_rate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(audio_codec_option_t),
                "::",
                stringify!(pcm_sample_rate)
            )
        );
    }
    test_field_pcm_sample_rate();
    fn test_field_pcm_channel_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audio_codec_option_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pcm_channel_num) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(audio_codec_option_t),
                "::",
                stringify!(pcm_channel_num)
            )
        );
    }
    test_field_pcm_channel_num();
}
#[doc = " The definition of the rtc_channel_options_t struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtc_channel_options_t {
    pub auto_subscribe_audio: bool,
    pub auto_subscribe_video: bool,
    pub subscribe_local_user: bool,
    pub enable_audio_jitter_buffer: bool,
    pub enable_audio_mixer: bool,
    pub audio_codec_opt: audio_codec_option_t,
    pub enable_aut_encryption: bool,
}
#[test]
fn bindgen_test_layout_rtc_channel_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rtc_channel_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(rtc_channel_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rtc_channel_options_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rtc_channel_options_t))
    );
    fn test_field_auto_subscribe_audio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_channel_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).auto_subscribe_audio) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_channel_options_t),
                "::",
                stringify!(auto_subscribe_audio)
            )
        );
    }
    test_field_auto_subscribe_audio();
    fn test_field_auto_subscribe_video() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_channel_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).auto_subscribe_video) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_channel_options_t),
                "::",
                stringify!(auto_subscribe_video)
            )
        );
    }
    test_field_auto_subscribe_video();
    fn test_field_subscribe_local_user() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_channel_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subscribe_local_user) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_channel_options_t),
                "::",
                stringify!(subscribe_local_user)
            )
        );
    }
    test_field_subscribe_local_user();
    fn test_field_enable_audio_jitter_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_channel_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable_audio_jitter_buffer) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_channel_options_t),
                "::",
                stringify!(enable_audio_jitter_buffer)
            )
        );
    }
    test_field_enable_audio_jitter_buffer();
    fn test_field_enable_audio_mixer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_channel_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable_audio_mixer) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_channel_options_t),
                "::",
                stringify!(enable_audio_mixer)
            )
        );
    }
    test_field_enable_audio_mixer();
    fn test_field_audio_codec_opt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_channel_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).audio_codec_opt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_channel_options_t),
                "::",
                stringify!(audio_codec_opt)
            )
        );
    }
    test_field_audio_codec_opt();
    fn test_field_enable_aut_encryption() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rtc_channel_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable_aut_encryption) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(rtc_channel_options_t),
                "::",
                stringify!(enable_aut_encryption)
            )
        );
    }
    test_field_enable_aut_encryption();
}
pub const cloud_proxy_type_e_CLOUD_PROXY_NONE: cloud_proxy_type_e = 0;
pub const cloud_proxy_type_e_CLOUD_PROXY_UDP: cloud_proxy_type_e = 1;
pub const cloud_proxy_type_e_CLOUD_PROXY_TCP: cloud_proxy_type_e = 3;
pub const cloud_proxy_type_e_CLOUD_PROXY_AUTO: cloud_proxy_type_e = 100;
pub type cloud_proxy_type_e = ::std::os::raw::c_uint;
pub const network_event_type_e_NETWORK_EVENT_DOWN: network_event_type_e = 0;
pub const network_event_type_e_NETWORK_EVENT_UP: network_event_type_e = 1;
pub const network_event_type_e_NETWORK_EVENT_CHANGE: network_event_type_e = 2;
#[doc = " Network event type enum"]
pub type network_event_type_e = ::std::os::raw::c_uint;
#[doc = " Connection identification"]
pub type connection_id_t = u32;
#[doc = " connection info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct connection_info_t {
    pub conn_id: connection_id_t,
    pub uid: u32,
    pub channel_name: [::std::os::raw::c_char; 65usize],
}
#[test]
fn bindgen_test_layout_connection_info_t() {
    assert_eq!(
        ::std::mem::size_of::<connection_info_t>(),
        76usize,
        concat!("Size of: ", stringify!(connection_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<connection_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(connection_info_t))
    );
    fn test_field_conn_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<connection_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conn_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(connection_info_t),
                "::",
                stringify!(conn_id)
            )
        );
    }
    test_field_conn_id();
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<connection_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(connection_info_t),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_channel_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<connection_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(connection_info_t),
                "::",
                stringify!(channel_name)
            )
        );
    }
    test_field_channel_name();
}
#[doc = " Agora RTC SDK event handler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct agora_rtc_event_handler_t {
    #[doc = " Occurs when local user joins channel successfully."]
    #[doc = ""]
    #[doc = " @param[in] conn_id    Connection identification"]
    #[doc = " param[in] uid         local uid"]
    #[doc = " @param[in] elapsed_ms Time elapsed (ms) since channel is established"]
    pub on_join_channel_success: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, uid: u32, elapsed_ms: ::std::os::raw::c_int),
    >,
    #[doc = " Occurs when channel is disconnected from the server."]
    #[doc = ""]
    #[doc = " @param[in] conn_id    Connection identification"]
    pub on_connection_lost: ::std::option::Option<unsafe extern "C" fn(conn_id: connection_id_t)>,
    #[doc = " Occurs when local user rejoins channel successfully after disconnect"]
    #[doc = ""]
    #[doc = " When channel loses connection with server due to network problems,"]
    #[doc = " SDK will retry to connect automatically. If success, it will be triggered."]
    #[doc = ""]
    #[doc = " @param[in] conn_id    Connection identification"]
    #[doc = " @param[in] uid        local uid"]
    #[doc = " @param[in] elapsed_ms Time elapsed (ms) since rejoin due to network"]
    pub on_rejoin_channel_success: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, uid: u32, elapsed_ms: ::std::os::raw::c_int),
    >,
    #[doc = " Report error message during runtime."]
    #[doc = ""]
    #[doc = " In most cases, it means SDK can't fix the issue and application should take action."]
    #[doc = ""]
    #[doc = " @param[in] conn_id Connection identification"]
    #[doc = " @param[in] code    Error code, see #agora_err_code_e"]
    #[doc = " @param[in] msg     Error message"]
    pub on_error: ::std::option::Option<
        unsafe extern "C" fn(
            conn_id: connection_id_t,
            code: ::std::os::raw::c_int,
            msg: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Occurs when a remote user joins channel successfully."]
    #[doc = ""]
    #[doc = " @param[in] conn_id    Connection identification"]
    #[doc = " @param[in] uid        Remote user ID"]
    #[doc = " @param[in] elapsed_ms Time elapsed (ms) since channel is established"]
    pub on_user_joined: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, uid: u32, elapsed_ms: ::std::os::raw::c_int),
    >,
    #[doc = " Occurs when remote user leaves the channel."]
    #[doc = ""]
    #[doc = " @param[in] conn_id Connection identification"]
    #[doc = " @param[in] uid     Remote user ID"]
    #[doc = " @param[in] reason  Reason, see #user_offline_reason_e"]
    pub on_user_offline: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, uid: u32, reason: ::std::os::raw::c_int),
    >,
    #[doc = " Occurs when a remote user sends notification before enable/disable sending audio."]
    #[doc = ""]
    #[doc = " @param[in] conn_id Connection identification"]
    #[doc = " @param[in] uid     Remote user ID"]
    #[doc = " @param[in] muted   Mute status:"]
    #[doc = "                    - false(0): unmuted"]
    #[doc = "                    - true (1): muted"]
    pub on_user_mute_audio: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, uid: u32, muted: bool),
    >,
    #[doc = " Occurs when a remote user sends notification before enable/disable sending video."]
    #[doc = ""]
    #[doc = " @param[in] conn_id Connection identification"]
    #[doc = " @param[in] uid     Remote user ID"]
    #[doc = " @param[in] muted   Mute status:"]
    #[doc = "                    - false(0): unmuted"]
    #[doc = "                    - true (1): muted"]
    pub on_user_mute_video: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, uid: u32, muted: bool),
    >,
    #[doc = " Occurs when receiving the audio frame of a remote user in the channel."]
    #[doc = ""]
    #[doc = " @param[in] conn_id    Connection identification"]
    #[doc = " @param[in] uid        Remote user ID to which data is sent"]
    #[doc = " @param[in] sent_ts    Timestamp (ms) for sending data"]
    #[doc = " @param[in] data_ptr   Audio frame buffer"]
    #[doc = " @param[in] data_len   Audio frame buffer length (bytes)"]
    #[doc = " @param[in] frame_info Audio frame info"]
    pub on_audio_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn_id: connection_id_t,
            uid: u32,
            sent_ts: u16,
            data_ptr: *const ::std::os::raw::c_void,
            data_len: size_t,
            info_ptr: *const audio_frame_info_t,
        ),
    >,
    #[doc = " Occurs every 20ms."]
    #[doc = ""]
    #[doc = " @param[in] conn_id     Connection identification"]
    #[doc = " @param[in] data_ptr    Audio frame buffer"]
    #[doc = " @param[in] data_len    Audio frame buffer length (bytes)"]
    #[doc = " @param[in] frame_info  Audio frame info"]
    pub on_mixed_audio_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn_id: connection_id_t,
            data_ptr: *const ::std::os::raw::c_void,
            data_len: size_t,
            info_ptr: *const audio_frame_info_t,
        ),
    >,
    #[doc = " Occurs when receiving the video frame of a remote user in the channel."]
    #[doc = ""]
    #[doc = " @param[in] conn_id      Connection identification"]
    #[doc = " @param[in] uid          Remote user ID to which data is sent"]
    #[doc = " @param[in] sent_ts      Timestamp (ms) for sending data"]
    #[doc = " @param[in] data_ptr     Video frame buffer"]
    #[doc = " @param[in] data_len     Video frame buffer lenth (bytes)"]
    #[doc = " @param[in] frame_info   Video frame info"]
    pub on_video_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn_id: connection_id_t,
            uid: u32,
            sent_ts: u16,
            data_ptr: *const ::std::os::raw::c_void,
            data_len: size_t,
            info_ptr: *const video_frame_info_t,
        ),
    >,
    #[doc = " Occurs when network bandwidth change is detected. User is expected to adjust encoder bitrate to |target_bps|"]
    #[doc = ""]
    #[doc = " @param[in] conn_id    Connection identification"]
    #[doc = " @param[in] target_bps Target value (bps) by which the bitrate should update"]
    pub on_target_bitrate_changed:
        ::std::option::Option<unsafe extern "C" fn(conn_id: connection_id_t, target_bps: u32)>,
    #[doc = " Occurs when a remote user requests a keyframe."]
    #[doc = ""]
    #[doc = " This callback notifies the sender to generate a new keyframe."]
    #[doc = ""]
    #[doc = " @param[in] conn_id      Connection identification"]
    #[doc = " @param[in] uid          Remote user ID"]
    #[doc = " @param[in] stream_type  Stream type for which a keyframe is requested"]
    pub on_key_frame_gen_req: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, uid: u32, stream_type: video_stream_type_e),
    >,
    #[doc = " Occurs when token will expired."]
    #[doc = ""]
    #[doc = " @param[in] conn_id    Connection identification"]
    #[doc = " @param[in] token      The token will expire"]
    pub on_token_privilege_will_expire: ::std::option::Option<
        unsafe extern "C" fn(conn_id: connection_id_t, token: *const ::std::os::raw::c_char),
    >,
}
#[test]
fn bindgen_test_layout_agora_rtc_event_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<agora_rtc_event_handler_t>(),
        112usize,
        concat!("Size of: ", stringify!(agora_rtc_event_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<agora_rtc_event_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(agora_rtc_event_handler_t))
    );
    fn test_field_on_join_channel_success() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_join_channel_success) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_join_channel_success)
            )
        );
    }
    test_field_on_join_channel_success();
    fn test_field_on_connection_lost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_connection_lost) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_connection_lost)
            )
        );
    }
    test_field_on_connection_lost();
    fn test_field_on_rejoin_channel_success() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_rejoin_channel_success) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_rejoin_channel_success)
            )
        );
    }
    test_field_on_rejoin_channel_success();
    fn test_field_on_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_error) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_error)
            )
        );
    }
    test_field_on_error();
    fn test_field_on_user_joined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_user_joined) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_user_joined)
            )
        );
    }
    test_field_on_user_joined();
    fn test_field_on_user_offline() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_user_offline) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_user_offline)
            )
        );
    }
    test_field_on_user_offline();
    fn test_field_on_user_mute_audio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_user_mute_audio) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_user_mute_audio)
            )
        );
    }
    test_field_on_user_mute_audio();
    fn test_field_on_user_mute_video() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_user_mute_video) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_user_mute_video)
            )
        );
    }
    test_field_on_user_mute_video();
    fn test_field_on_audio_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_audio_data) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_audio_data)
            )
        );
    }
    test_field_on_audio_data();
    fn test_field_on_mixed_audio_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_mixed_audio_data) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_mixed_audio_data)
            )
        );
    }
    test_field_on_mixed_audio_data();
    fn test_field_on_video_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_video_data) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_video_data)
            )
        );
    }
    test_field_on_video_data();
    fn test_field_on_target_bitrate_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_target_bitrate_changed) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_target_bitrate_changed)
            )
        );
    }
    test_field_on_target_bitrate_changed();
    fn test_field_on_key_frame_gen_req() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_key_frame_gen_req) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_key_frame_gen_req)
            )
        );
    }
    test_field_on_key_frame_gen_req();
    fn test_field_on_token_privilege_will_expire() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtc_event_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_token_privilege_will_expire) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtc_event_handler_t),
                "::",
                stringify!(on_token_privilege_will_expire)
            )
        );
    }
    test_field_on_token_privilege_will_expire();
}
extern "C" {
    #[doc = " @brief Get SDK version."]
    #[doc = " @return A const static string describes the SDK version"]
    pub fn agora_rtc_get_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Convert error code to const static string."]
    #[doc = " @note You do not have to release the string after use."]
    #[doc = " @param[in] err Error code"]
    #[doc = " @return Const static error string"]
    pub fn agora_rtc_err_2_str(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Generate a credential which is a unique device identifier."]
    #[doc = " @note It's authorizing smart devices license."]
    #[doc = "       You can disregard it if license isn't used."]
    #[doc = " @param[out]    credential        Credential buffer holding the generated data"]
    #[doc = " @param[in,out] credential_len    Credential buffer length (bytes), which should be larger than AGORA_CREDENTIAL_MAX_LEN"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_license_gen_credential(
        credential: *mut ::std::os::raw::c_char,
        credential_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Authenticate the SDK licence."]
    #[doc = " @note"]
    #[doc = " - It's authorizing smart devices license."]
    #[doc = "   You can disregard it if you do not use a license."]
    #[doc = "   Once the license is enabled, only the authenticated SDK can be used."]
    #[doc = " - This API should be invoked before agora_rtc_init"]
    #[doc = " @param[in] certificate     Certificate buffer"]
    #[doc = " @param[in] certificate_len Certificate buffer length"]
    #[doc = " @param[in] credential      Credential buffer"]
    #[doc = " @param[in] credential_len  Credential buffer length"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_license_verify(
        certificate: *const ::std::os::raw::c_char,
        certificate_len: ::std::os::raw::c_int,
        credential: *const ::std::os::raw::c_char,
        credential_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize the Agora RTSA service."]
    #[doc = " @note Each process can only be initialized once."]
    #[doc = " @param[in] app_id          Application ID"]
    #[doc = "                            If 'uid' is set as 0, SDK will assign a valid ID to the user"]
    #[doc = " @param[in] event_handler   A set of callback that handles Agora SDK events"]
    #[doc = " @param[in] option          RTC service option when init, If need't set option, set NULL"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_init(
        app_id: *const ::std::os::raw::c_char,
        event_handler: *const agora_rtc_event_handler_t,
        option: *mut rtc_service_option_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Release all resource allocated by Agora RTSA SDK"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_fini() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the log level."]
    #[doc = " @param[in] level Log level. Range reference to rtc_log_level_e enum"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_set_log_level(level: rtc_log_level_e) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the log file configuration."]
    #[doc = " @param[in] per_logfile_size The size (bytes) of each log file."]
    #[doc = "                             The value range is [0, 10*1024*1024(10MB)], default 1*1024*1024(1MB)."]
    #[doc = "                             0 means set log off"]
    #[doc = " @param[in] logfile_roll_count The maximum number of log file numbers."]
    #[doc = "                               The value range is [0, 100], default 10."]
    #[doc = "                               0 means set log off"]
    #[doc = " @return"]
    #[doc = " - 0: Success."]
    #[doc = " - <0: Failure."]
    pub fn agora_rtc_config_log(
        size_per_file: ::std::os::raw::c_int,
        max_file_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a connection, connection can join channel"]
    #[doc = " @param[out] conn_id: Store created connection id"]
    #[doc = " @return"]
    #[doc = "  - =0: Success"]
    #[doc = "  - <0: Failure"]
    pub fn agora_rtc_create_connection(conn_id: *mut connection_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Destroy a connection"]
    #[doc = " @param[in] conn_id    : Connection identification"]
    #[doc = " @return"]
    #[doc = "  - =0: Success"]
    #[doc = "  - <0: Failure"]
    pub fn agora_rtc_destroy_connection(conn_id: connection_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get a connection info"]
    #[doc = " @param[in] conn_id    : Connection identification"]
    #[doc = " @param[out] conn_info : Connection info"]
    #[doc = " @return"]
    #[doc = "  - =0: Success"]
    #[doc = "  - <0: Failure"]
    pub fn agora_rtc_get_connection_info(
        conn_id: connection_id_t,
        conn_info: *mut connection_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Local user joins channel."]
    #[doc = " @note Users in the same channel with the same App ID can send data to each other."]
    #[doc = "       You can join more than one channel at the same time. All channels that"]
    #[doc = "       you join will receive the audio/video data stream that you send unless"]
    #[doc = "       you stop sending the audio/video data stream in a specific channel."]
    #[doc = " @param[in] conn_id      : Connection identification"]
    #[doc = " @param[in] channel_name : Channel name"]
    #[doc = "            Length=strlen(channel_name) should be less than 64 bytes"]
    #[doc = "            Supported character scopes are:"]
    #[doc = "            - The 26 lowercase English letters: a to z"]
    #[doc = "            - The 26 uppercase English letters: A to Z"]
    #[doc = "            - The 10 numbers: 0 to 9"]
    #[doc = "            - The space"]
    #[doc = "            - \"!\", \"#\", \"$\", \"%\", \"&\", \"(\", \")\", \"+\", \"-\", \":\", \";\", \"<\","]
    #[doc = "              \"=\", \".\", \">\", \"?\", \"@\", \"[\", \"]\", \"^\", \"_\", \" {\", \"}\", \"|\", \"~\", \",\""]
    #[doc = " @param[in] uid   : User ID."]
    #[doc = "                   A 32-bit unsigned integer with a value ranging from 1 to 2^32-1. The uid must be unique."]
    #[doc = "                   If a uid is set to 0, the SDK assigns and returns a uid in the on_join_channel_success callback."]
    #[doc = "                     Your application must record and maintain the returned uid, because the SDK does not do so."]
    #[doc = " @param[in] token : Token string generated by the server, length=strlen(token) Range is [32, 512]"]
    #[doc = "                      - if token authorization is enabled on developer website, it should be set correctly"]
    #[doc = "                      - else token can be set as `NULL`"]
    #[doc = " @param[in] options   channel options when create channel."]
    #[doc = "                      If do not set channel options, set NULL"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_join_channel(
        conn_id: connection_id_t,
        channel_name: *const ::std::os::raw::c_char,
        uid: u32,
        token: *const ::std::os::raw::c_char,
        options: *mut rtc_channel_options_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allow Local user leaves channel."]
    #[doc = " @note Local user should leave channel when data transmission is stopped"]
    #[doc = " @param[in] conn_id   : Connection identification"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_leave_channel(conn_id: connection_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Renew token for specific channel OR all channels."]
    #[doc = " @note Token should be renewed when valid duration reached expiration."]
    #[doc = " @param[in] conn_id   Connection identification"]
    #[doc = " @param[in] token     Token string, strlen(token) Range is [32, 512]"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_renew_token(
        conn_id: connection_id_t,
        token: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set network state"]
    #[doc = " @note It should only be used on systems where the SDK is not aware of network events, such as Android11 and later."]
    #[doc = " @param event : network event, ref@network_event_type_e"]
    #[doc = " @return =0: success; <0: failure"]
    pub fn agora_rtc_notify_network_event(event: network_event_type_e) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Decide whether to enable/disable sending local audio data to specific channel OR all channels."]
    #[doc = " @param[in] conn_id   Connection identification, if set CONNECTION_ID_ALL(0) is for all connections"]
    #[doc = " @param[in] mute      Toggle sending local audio"]
    #[doc = "                      - false(0): unmuted"]
    #[doc = "                      - true (1): muted"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_mute_local_audio(
        conn_id: connection_id_t,
        mute: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Decide whether to enable/disable sending local video data to specific channel OR all channels."]
    #[doc = " @param[in] conn_id   Connection identification, if set CONNECTION_ID_ALL(0) is for all connections"]
    #[doc = " @param[in] mute      Toggle sending local video"]
    #[doc = "                      - false(0): unmuted"]
    #[doc = "                      - true (1): muted"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_mute_local_video(
        conn_id: connection_id_t,
        mute: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Decide whether to enable/disable receiving remote audio data from specific channel OR all channels."]
    #[doc = " @param[in] conn_id      Connection identification, if set CONNECTION_ID_ALL(0) is for all connections"]
    #[doc = " @param[in] remote_uid    Remote user ID"]
    #[doc = "                          - if `remote_uid` is set 0, it's for all users"]
    #[doc = "                          - else it's for specific user"]
    #[doc = " @param[in] mute          Toggle receiving remote audio"]
    #[doc = "                          - false(0): unmuted"]
    #[doc = "                          - true (1): muted"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_mute_remote_audio(
        conn_id: connection_id_t,
        remote_uid: u32,
        mute: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Decide whether to enable/disable receiving remote video data from specific channel OR all channels."]
    #[doc = " @param[in] conn_id       Connection identification, if set CONNECTION_ID_ALL(0) is for all connections"]
    #[doc = " @param[in] remote_uid    Remote user ID"]
    #[doc = "                          - if `remote_uid` is set 0, it's for all users"]
    #[doc = "                          - else it's for specific user"]
    #[doc = " @param[in] mute          Toggle receiving remote video"]
    #[doc = "                          - false(0): unmuted"]
    #[doc = "                          - true (1): muted"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_mute_remote_video(
        conn_id: connection_id_t,
        remote_uid: u32,
        mute: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Request remote user to generate a keyframe for all video streams OR specific video stream."]
    #[doc = " @param[in] conn_id      Connection identification"]
    #[doc = " @param[in] remote_uid   Remote user ID"]
    #[doc = "                         - if `remote_uid` is set 0, it's for all users"]
    #[doc = "                         - else it's for specific user"]
    #[doc = " @param[in] stream_type    Stream type"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_request_video_key_frame(
        conn_id: connection_id_t,
        remote_uid: u32,
        stream_type: video_stream_type_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send an audio frame to all channels OR specific channel."]
    #[doc = "        All remote users in this channel will receive the audio frame."]
    #[doc = " @note All channels that you joined will receive the audio frame that you send"]
    #[doc = "       unless you stop sending the local audio to a specific channel."]
    #[doc = " @param[in] conn_id   Connection identification"]
    #[doc = " @param[in] data_ptr  Audio frame buffer"]
    #[doc = " @param[in] data_len  Audio frame buffer length (bytes)"]
    #[doc = " @param[in] info_ptr  Audio frame info, see #audio_frame_info_t"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_send_audio_data(
        conn_id: connection_id_t,
        data_ptr: *const ::std::os::raw::c_void,
        data_len: size_t,
        info_ptr: *mut audio_frame_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send a video frame to all channels OR specific channel."]
    #[doc = "        All remote users in the channel will receive the video frame."]
    #[doc = " @note All channels that you join will receive the video frame that you send"]
    #[doc = "       unless you stop sending the local video to a specific channel."]
    #[doc = " @param[in] conn_id   Connection identification"]
    #[doc = " @param[in] data_ptr  Video frame buffer"]
    #[doc = " @param[in] data_len  Video frame buffer length (bytes)"]
    #[doc = " @param[in] info_ptr  Video frame info"]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_send_video_data(
        conn_id: connection_id_t,
        data_ptr: *const ::std::os::raw::c_void,
        data_len: size_t,
        info_ptr: *mut video_frame_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set network bandwdith estimation (bwe) param"]
    #[doc = " @param[in] conn_id   : Connection identification, if set CONNECTION_ID_ALL(0) is for all connections"]
    #[doc = " @param[in] min_bps   : bwe min bps"]
    #[doc = " @param[in] max_bps   : bwe max bps"]
    #[doc = " @param[in] start_bps : bwe start bps"]
    #[doc = ""]
    #[doc = " @return:"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_set_bwe_param(
        conn_id: connection_id_t,
        min_bps: u32,
        max_bps: u32,
        start_bps: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set config params"]
    #[doc = ""]
    #[doc = " @param [in] params : config params described by json"]
    #[doc = " @note  supported sets are shown below, they can be together in params json string"]
    #[doc = "  - {\"rtc.encryption\": {\"enable\": true/false, \"master_key\": \"xxx...\"}}"]
    #[doc = "  - {\"rtc_network\": { \"type\": INT_xx, \"id\": INT_xx, \"update\": true|false }}"]
    #[doc = " @return:"]
    #[doc = "  - = 0: Success"]
    #[doc = "  - < 0: Failure"]
    pub fn agora_rtc_set_params(params: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[doc = " 0: LOGIN"]
pub const rtm_event_type_e_RTM_EVENT_TYPE_LOGIN: rtm_event_type_e = 0;
#[doc = " 1: KICKOFF"]
pub const rtm_event_type_e_RTM_EVENT_TYPE_KICKOFF: rtm_event_type_e = 1;
#[doc = " 2: EXIT"]
pub const rtm_event_type_e_RTM_EVENT_TYPE_EXIT: rtm_event_type_e = 2;
#[doc = " RTM event type list"]
pub type rtm_event_type_e = ::std::os::raw::c_uint;
#[doc = " no error"]
pub const rtm_err_code_e_ERR_RTM_OK: rtm_err_code_e = 0;
#[doc = " general error"]
pub const rtm_err_code_e_ERR_RTM_FAILED: rtm_err_code_e = 1;
#[doc = " Login is rejected by the server."]
pub const rtm_err_code_e_ERR_RTM_LOGIN_REJECTED: rtm_err_code_e = 2;
#[doc = "  invalid rtm uid"]
pub const rtm_err_code_e_ERR_RTM_INVALID_RTM_UID: rtm_err_code_e = 3;
#[doc = " The token is invalid."]
pub const rtm_err_code_e_ERR_RTM_LOGIN_INVALID_TOKEN: rtm_err_code_e = 5;
#[doc = " Unauthorized login."]
pub const rtm_err_code_e_ERR_RTM_LOGIN_NOT_AUTHORIZED: rtm_err_code_e = 7;
#[doc = "  invalid appid"]
pub const rtm_err_code_e_ERR_RTM_INVALID_APP_ID: rtm_err_code_e = 101;
#[doc = " The server rejected the request to look up the channel"]
pub const rtm_err_code_e_WARN_RTM_LOOKUP_CHANNEL_REJECTED: rtm_err_code_e = 105;
#[doc = " Authorized Timestamp expired"]
pub const rtm_err_code_e_ERR_RTM_TOKEN_EXPIRED: rtm_err_code_e = 109;
#[doc = " invalid token"]
pub const rtm_err_code_e_ERR_RTM_INVALID_TOKEN: rtm_err_code_e = 110;
pub type rtm_err_code_e = ::std::os::raw::c_uint;
#[doc = " Agora RTC SDK RTM event handler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct agora_rtm_handler_t {
    #[doc = " Occurs when data comes from RTM"]
    #[doc = " @param[in] rtm_uid    The remote rtm uid which the data come from."]
    #[doc = " @param[in] msg        The Data received."]
    #[doc = " @param[in] msg_len    Length of the data received."]
    pub on_rtm_data: ::std::option::Option<
        unsafe extern "C" fn(
            rtm_uid: *const ::std::os::raw::c_char,
            msg: *const ::std::os::raw::c_void,
            msg_len: size_t,
        ),
    >,
    #[doc = " Occurs when RTM event occurs"]
    #[doc = " @param[in] rtm_uid    RTM UID"]
    #[doc = " @param[in] event_type Event type"]
    #[doc = " @param[in] event_info Event info of event type"]
    pub on_rtm_event: ::std::option::Option<
        unsafe extern "C" fn(
            rtm_uid: *const ::std::os::raw::c_char,
            event_type: rtm_event_type_e,
            err_code: rtm_err_code_e,
        ),
    >,
    #[doc = " Report the result of the \"agora_rtc_send_rtm_data\" method call"]
    #[doc = " @param[in] msg_id     Identify one message"]
    #[doc = " @param[in] error_code Error code number"]
    #[doc = "                       - 0 : success"]
    #[doc = "                       - 1 : failure"]
    pub on_send_rtm_data_result:
        ::std::option::Option<unsafe extern "C" fn(msg_id: u32, error_code: rtm_err_code_e)>,
}
#[test]
fn bindgen_test_layout_agora_rtm_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<agora_rtm_handler_t>(),
        24usize,
        concat!("Size of: ", stringify!(agora_rtm_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<agora_rtm_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(agora_rtm_handler_t))
    );
    fn test_field_on_rtm_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtm_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_rtm_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtm_handler_t),
                "::",
                stringify!(on_rtm_data)
            )
        );
    }
    test_field_on_rtm_data();
    fn test_field_on_rtm_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtm_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_rtm_event) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtm_handler_t),
                "::",
                stringify!(on_rtm_event)
            )
        );
    }
    test_field_on_rtm_event();
    fn test_field_on_send_rtm_data_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<agora_rtm_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_send_rtm_data_result) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(agora_rtm_handler_t),
                "::",
                stringify!(on_send_rtm_data_result)
            )
        );
    }
    test_field_on_send_rtm_data_result();
}
extern "C" {
    #[doc = " Login agora RTM service"]
    #[doc = " @param[in] rtm_uid   RTM user id (different from uid)"]
    #[doc = "                      Length should be less than 64 bytes"]
    #[doc = "                      Supported character scopes are:"]
    #[doc = "                      - The 26 lowercase English letters: a to z"]
    #[doc = "                      - The 26 uppercase English letters: A to Z"]
    #[doc = "                      - The 10 numbers: 0 to 9"]
    #[doc = "                      - The space"]
    #[doc = "                      - \"!\", \"#\", \"$\", \"%\", \"&\", \"(\", \")\", \"+\", \"-\", \":\","]
    #[doc = "                        \";\", \"<\", \"=\", \".\", \">\", \"?\", \"@\", \"[\", \"]\", \"^\","]
    #[doc = "                        \"_\", \" {\", \"}\", \"|\", \"~\", \",\""]
    #[doc = " @param[in] rtm_token  RTM token string generated by the token server (different from RTC token)"]
    #[doc = "                      - if token authorization is enabled on developer website, it should be set correctly"]
    #[doc = "                      - else token can be set as `NULL`"]
    #[doc = " @param[in] hanlder   A set of callback that handles Agora RTM events"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_login_rtm(
        rtm_uid: *const ::std::os::raw::c_char,
        rtm_token: *const ::std::os::raw::c_char,
        handler: *const agora_rtm_handler_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Logout agora RTM service"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_logout_rtm() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send data through Real-time Messaging (RTM) mechanism, which is a stable and reliable data channel"]
    #[doc = " @note RTM channel is not available by default, unless login success and callback `on_rtm_event`"]
    #[doc = "is triggered. The sending speed allowed is limited to 60 messages per second (60qps)"]
    #[doc = ""]
    #[doc = " @param[in] rtm_uid     RTM UID"]
    #[doc = " @param[in] msg_id  Identify the message sent"]
    #[doc = " @param[in] msg     Message to send"]
    #[doc = " @param[in] msg_len Length of the message(max size: 32KB)"]
    #[doc = ""]
    #[doc = " @return:"]
    #[doc = " - = 0: Success"]
    #[doc = " - < 0: Failure"]
    pub fn agora_rtc_send_rtm_data(
        rtm_uid: *const ::std::os::raw::c_char,
        msg_id: u32,
        msg: *const ::std::os::raw::c_void,
        msg_len: size_t,
    ) -> ::std::os::raw::c_int;
}
